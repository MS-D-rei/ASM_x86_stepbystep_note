; Build command
; rand-test: rand-test.o
; 	gcc -o rand-test -no-pie rand-test.o
; rand-test.o: rand-test.asm
; 	nasm -f elf64 -g -F dwarf rand-test.asm

; 64-bit calling convention parameter order
; RDI, RSI, RDX, RCX, R8, R9
; volatile registers
; RAX, RCX, RDX, RDI, RSI, R8, R9, R10
; nonvolatile registers
; RBP, RSP, RBX, R12, R13, R14, R15

section .data
	Pulls	dq 36
	DisplayMessage db 0x0a, "Here is an array of %d %d-bit random numbers: ", 0x0a, 0
	RandomNumberArray db "%10d %10d %10d %10d %10d %10d", 0x0a, 0
	NewLine db 0
	CharTable db "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-@" ; total 64 chars.

section .bss
	BufferSize 	equ 70           ; Number of randomly chosen chars.
	RandValue 	resq 1
	Stash 		resq 72
	RandChar 	resb BufferSize+2  ; Buffer for storing randomly chosen characters.

section .text
	extern printf
	extern puts
	extern rand
	extern srand
	extern time

; Get 31 bit random number from rand.
pull31:
	mov rcx, 0
	jmp pull

; Get 20 bit random number from rand.
; rand return 31 bit, so bit shift to the right by 11.
pull20:
	mov rcx, 11
	jmp pull

; Get 16 bit random number from rand.
; rand return 31 bit, so bit shift to the right by 15.
pull16:
	mov rcx, 15
	jmp pull

; Get 8 bit random number.
pull8:
	mov rcx, 23
	jmp pull

; Get 7 bit random number.
pull7:
	mov rcx, 24
	jmp pull

; Get 6 bit random number.
pull6:
	mov rcx, 25
	jmp pull

; Get 4 bit random number.
pull4: 
	mov rcx, 27 
	jmp pull

; RCX => int value from pullX instruction.
pull:
	push rbp                        ; Prolog: create stack frame.
	mov rbp, rsp

	mov r15, rcx                    ; Preserve RCX value in R15 because `rand` makes mess with RCX.
	call rand                       ; Takes no parameter. Return a value in RAX.
	mov rcx, r15                    ; Put back to RCX from R15.
	shr rax, cl                     ; Bit shift to the right by pullX RCX value.

	pop rbp                         ; Epilog: destroy stack frame.
	ret

; r13 => pullX instruction address.
; RAX => the result of `pull` instruction.
puller:
	push rbp
	mov rbp, rsp

	mov r12, [Pulls]                ; r12 = Pulls count (36).

; loop r12 => (Pulls count -1) to 0.
.grab:
	dec r12
	call r13                        ; Call `pullX` => `pull` instruction.
	mov [Stash+r12*8], rax          ; Contain the result of `pull` in Stash.
	cmp r12, 0                      ; 
	jne .grab                       ; Loop until r12 == 0.

	pop rbp
	ret

shownums:
	push rbp                        ; Prolog: create stack frame.
	mov rbp, rsp

	mov r12, qword [Pulls]          ; r12 = Pulls count.
	xor r13, r13

; Loop dorow while (r12 > 0)
.dorow:
	mov rdi, RandomNumberArray      ; The address of the message.
	mov rsi, [Stash+r13*8+0]        ; 1st parameter in RandomNumberArray.
	mov rdx, [Stash+r13*8+8]        ; 2nd.
	mov rcx, [Stash+r13*8+16]       ; 3rd.
	mov r8, [Stash+r13*8+24]        ; 4th.
	mov r9, [Stash+r13*8+32]        ; 5th.
	push rax                        ; To keep stack 16-btyes aligned.
	push qword [Stash+r13*8+40]     ; Pass 6th parameter on the stack.
	xor rax, rax
	call printf
	add rsp, 16                     ; Stack cleanup (2 items * 8 bytes = 16).

	add r13, 6                      ; One dorow call uses 6 qword data. Add 6 to move to next array.
	sub r12, 6                      ; One dorow call uses 6 qword data. So subtract 6 from the Pulls count.
	cmp r12, 0
	ja .dorow                       ; Loop while (r12 > 0).

	pop rbp                         ; Epilog: destroy stack frame.
	ret

;--------------------------------------------------------------------------------
; Main program

	global main

main:
	push rbp
	mov rbp, rsp

; Begin by seeding the random number generator with a time_t value.
Seed:
	xor rdi, rdi
	call time                        ; If RDI == 0, return time_t value in RAX.
	mov rdi, rax                     ; Put time_t value in RDI for srand call.
	call srand                       ; Generate value.

	mov r13, pull31                  ; r13 works as a parameter of puller. Put pull31 address to call it in `puller`.
	call puller                      ; Fill Stash with random numbers generated by pull instruction.

	; Show "Here is an array of {Pulls} 32-bit random numbers: {shownums}".
	mov rdi, DisplayMessage
	mov rsi, [Pulls]
	mov rdx, 32
	call printf                      ; Show "Here is ... number: ".
	call shownums                    ; Show each number in Stash.

	mov r13, pull20
	call puller

	mov rdi, DisplayMessage
	mov rsi, [Pulls]
	mov rdx, 20
	call printf
	call shownums

	mov r13, pull16
	call puller

	mov rdi, DisplayMessage
	mov rsi, [Pulls]
	mov rdx, 16
	call printf
	call shownums

	mov r13, pull8
	call puller

	mov rdi, DisplayMessage
	mov rsi, [Pulls]
	mov rdx, 8
	call printf
	call shownums

	mov r13, pull7
	call puller

	mov rdi, DisplayMessage
	mov rsi, [Pulls]
	mov rdx, 7
	call printf
	call shownums

	mov r13, pull6
	call puller

	mov rdi, DisplayMessage
	mov rsi, [Pulls]
	mov rdx, 6
	call printf
	call shownums

	mov r13, pull4
	call puller

	mov rdi, DisplayMessage
	mov rsi, [Pulls]
	mov rdx, 4
	call printf
	call shownums

; Fill RandChar with 0
bufferclear:
	mov rcx, BufferSize+2                ; +2 is for safety
.loop:
	dec rcx
	mov byte [RandChar+rcx], 0
	cmp rcx, 0
	jnz .loop

pullchar:
	mov rbx, BufferSize
.loop:
	dec rbx
	mov r13, pull6
	call r13                             ; RAX = 6 bit random number. 2 in power of 6 = 63.
	mov cl, [CharTable+rax]              ; Select a char from CharTable.

	mov [RandChar+rbx], cl               ; Put the char in RandChar.
	cmp rbx, 0
	jne .loop                            ; Loop while (rbx > 0)

	; Output RandChar.
	mov rdi, NewLine
	call puts
	mov rdi, RandChar
	call puts
	mov rdi, NewLine
	call puts

	; mov rsp, rbp
	pop rbp
	; mov rp
	ret
